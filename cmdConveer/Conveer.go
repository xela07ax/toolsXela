package cmdConveer

import (
	"bytes"
	"fmt"
	"os/exec"
	"sync"
	"time"
)



type Box struct {
	boxData string //Какие то данные которые нужны для бизнеса
	boxData2 string //Какие то данные которые нужны для бизнеса
	dir string
	loger chan<- [4]string //Какие то данные которые нужны для бизнеса
	process *mutexRunner  // Системная функция конвеера, для открытия нового миньона без гонок
	ch chan Command  // Приемник данных, с которыми сервис будет работать
	OutCh chan Reject // Выходные даннае можно отправлять в следующий конвеер этим каналом
	stopPrepare *mutexStopper // Сигнал всем миньонам, что пока закругляться
	stopX chan bool // Миньон отправляет сигнал сюда, о завершении своей работы и уничтожения. Когда все отправят сигнал коннвеер прекратит работу
	GoodBy chan bool // Внешний сигнал, о том, что конвеер прекратил работу
}

func NewBalancer(boxData string,loger chan<- [4]string, ch chan Command) *Box { // <- Вход в библиотеку тут!
	fmt.Println("Модуль-балансировщик инициализирован") // Печатаем в консоль приветствие
	return &Box{
		boxData:boxData, //Присваеваем входные данные для использования всем миньонам
		loger:loger, //Присваеваем входные данные для использования всем миньонам
		ch:ch, // Входной канал можно передавать из вне, но если начало должно происходить внутри этого конвеера, то можно ее убрать вообще из использования и иницализировать только вывод
		OutCh:make(chan Reject, 10000), // Инициализируем буферный канал для вывода с буфером в 10000 стрингов свободного ожидания, при переполнении работа будет ожидать.
		// [0] = Статус
		// [1] = Комментарий
		// [2] = Текст

		// OutCh можно передавать и из вне, а можно как тут, инициализация внутри
		stopPrepare:new(mutexStopper), // Системная переменная, инициализация внутри
		process:new(mutexRunner),  // Системная переменная, инициализация внутри
		stopX:make(chan bool,1000),  // Системная переменная, инициализация внутри
		GoodBy:make(chan bool, 2),  // Системная переменная, инициализация внутри
	} // Отправляем ссылку на объект для его управления и слежения
}
// Область функций корректного завершения
// Более полное описание https://habr.com/ru/post/271789/
type mutexStopper struct {
	mu sync.Mutex // <-- этот мьютекс защищает от гонок
	x  bool // Cтатус, пора ли нам выходить когда входной канал опустел
}
// Внутренняя безопасная функция для установки статса "Пора закругляться" всем миньонам
func (c *mutexStopper) stopSignal()  {
	c.mu.Lock() // Блокируем все операции, с этой функцией, остальные ждут завершения
	defer c.mu.Unlock() // Отложеная разблокировка
	c.x = true // Устанавливаем заветный статус
	return // <-- разблокировка произойдет здесь, defer выполняются при выходе из функции
}
// Две публичные функции для завершения
// Первая
// вызывается в синхронном режиме (без приставки GO)
// Посылается сигнал "Стоп" всем миньонам, когда входящий канал опустеет и они все корректно пмрут, эта фкнкция перестанет держать вызывающую область.
// В Асинхронном режиме позволяет в фоновом подать сигнал закругляться, и сообщит о своей остановке в GoodBy
// В синхронном держит тело вызывающей фкнкции до корректного завершения, так же посылает сигнал в GoodBy
func (p *Box) Stop()  {
	p.stopPrepare.stopSignal() // Устанавливаем статус завершения, что бы все миньены знали о готовящемся выходе
	for i:=0; i <  p.GetCores(); i++ { // Джем подтверждения корректного завершения всех запущеных миньонов, количество запущеных отражается в p.GetCores()
		<-p.stopX // Получаем один сигнал, от одной рутины, значит она закончила работу
	}
	p.GoodBy <- true //Посылаем сигнал, что конвеер завершил все в канал. Такой же конывеер может получить этот сигнал и будет собирать манатки
	fmt.Println("Модуль-балансировщик завершил все миньоны")
	return
}
// Вторая
// вызывается как с приставкой GO, так и без
// На вход ждет канал с сигналом "Пора закругляться"
// Когда сигнал поступает, и мрут все миньоны посылает сигнал в публичный канал GoodBy.
// В Асинхронном режиме позволяет в фоновом режиме узнавать, что надо закругляться и сообщит о своей остановке
// В синхронном держит программу до получения сигнала и корректного завершения, так же посылает сигнал в GoodBy
func (p *Box) SignalStoper(off <-chan bool)  {
	<- off // Ждем сигнал true, для начала завершения программы
	p.Stop() // Сигнал получен, процесс пошел, прогресс не остановить. Будем тут пока все не кончится
	fmt.Println("Модуль-балансировщик завершил все миньоны") //Просто печатаем, что б видеть ход работы
	p.GoodBy <- true //Посылаем сигнал, что конвеер завершил все в канал. Такой же конывеер может получить этот сигнал и будет собирать манатки
	return // Данный конвеер завершил свою работу. Остаются жить только присвоеные в объект данные за время жизни, пока они кому нибудь нужны из вне.
}
// Область функций корректного завершения здесь заканчивается

// Область для безопасного открытия миньюна
// Более полное описание https://habr.com/ru/post/271789/
type mutexRunner struct {
	mu sync.Mutex // <-- этот мьютекс защищает инкремент ниже
	x  int // <-- это поле под ним
}
func (c *mutexRunner) addRun()(i int)  {
	c.mu.Lock() // Блокируем выполнение все операции, что бы код в нутри выполнялся только этот, а остальные ждали завершения
	defer c.mu.Unlock()
	c.x++ //Простая операция инкремента
	i = c.x // Обновляем информацию об объекте
	// какой-нибудь интересный код, который можно выполнять без страха гонок
	// <-- defer не будет выполнен тут, как кто-нибудь *может* подумать
	return // <-- разблокировка произойдет здесь, defer выполняются при выходе из функции
}
//Мункция, для запроса охраняемого значения, например тут количество запущеных миньончиков
func (c *Box) GetCores()(cores int)  { // Сразу объявляем еременную на вывод
	c.process.mu.Lock() // Блокируем выполнение все операции, что бы ничего не могло помешать
	cores = c.process.x // Считываем количество запущеным миньонов и присваеваем в выходную переменную
	c.process.mu.Unlock() // <-- разблокировка произойдет здесь
	return // Поскольку выходная переменная уже объявлена и заполнена, можно ничего тут больше не писать. Го все понял и функция завершает работу.
}

// Собственно сам внешний вызов, для безопасного открытия миньюна
func (p *Box) RunMinion()  {
	go p.minion(p.process.addRun())
	// Так же нам возвращается порядковый номер миньона, которы номеруется с 1-го и передается в конвеер.
	// Rак видно, ничего держать эту функцию не будет, она асинхронна
	// Миньон может быть еще не создан, но работа над этим идет
	return
}

// Все самое интересное начинается тут
func (p *Box) minion(gophere int)  {
	fmt.Printf("Миньен %d инициализирован\n",gophere) //Печатаем ход работ.
	/*
	Какой то код, который нужно выполнить до того как начнется сам процесс считывания данных со входящкго канала
	 */
    ticker := time.NewTicker(time.Duration(1000) * time.Millisecond)

	for  { // Начинается тело сканирования каналов, из цикла выходить не планируем, завершение цикла будет завершение функции
		select { // Смотрим в какие каналы пришли данные и считываем с него
		case elem := <-p.ch: // Канал данных, с которыми нужно проводить какие то операции, к примеру строки или уже обработаные другим конвеером строки
			// Самое интересное место программы, для него вся эта обложка.
			// Какой то интересный код
			// [0] = ExecCommand
			// [1] = Домашняя директория
			// [2] = Команда
			// We'll use ping as it will provide output and we can control how long it runs.
			if elem.Timeout == 0 {
				elem.Timeout = 999
			}
			p.loger<- [4]string{"Conveer",fmt.Sprintf("Minion%d",gophere),fmt.Sprintf("Выполняю команду: %s | osWorkDir:%s | exec:%s | Args:%v",elem.Name,elem.DirHome,elem.Executer,elem.Args)}
			cmd := exec.Command(elem.Executer,elem.Args...)
			cmd.Dir = elem.DirHome
			// Use a bytes.Buffer to get the output
			var buf bytes.Buffer
			cmd.Stdout = &buf
			var bufErr bytes.Buffer
			cmd.Stderr = &bufErr

			err := cmd.Start()
			if err != nil{
				p.loger<- [4]string{"Conveer","nil",fmt.Sprintf("Не удалось запустить команду: %v",err),"1"}
			}
			// Use a channel to signal completion so we can use a select statement
			done := make(chan error)
			go func() { done <- cmd.Wait() }()

			// Start a timer
			timeout := time.After(elem.Timeout * time.Second)

			select {
			case <-timeout:
				// Timeout happened first, kill the process and print a message.
				err := cmd.Process.Kill()
				p.loger<- [4]string{"Conveer","nil",fmt.Sprintf("Экзекутер приостановлен по таймаюту, пробуем еще раз. Статус завершения: %v",err),"1"}
				p.OutCh <- Reject{Name:elem.Name,Status:1,MyStderr:bufErr.String(),MyStdout:buf.String(),Comment:"Timeout",Command:elem}
				continue
			case err := <-done:
				//p.loger<- [4]string{"Conveer","nil",fmt.Sprintf("Статус завершения Экзекутера: %v",err)}
				// Command completed before timeout. Print output and error if it exists.
				//fmt.Println("Output:", buf.String())
				if err != nil {
					p.OutCh <- Reject{Name:elem.Name,Status:1,MyStderr:bufErr.String(),MyStdout:buf.String(),Comment:"Команда завершилась с ошибкой",Command:elem}
					continue
				}
				//fmt.Println("DDDDD")
				//newElement := fmt.Sprintf("%s - ок!", elem) // к примеру первому элементу подставим "- ок"
				p.OutCh <- Reject{Name:elem.Name,Status:0,MyStdout:buf.String(),Comment:"Команда выполнена",Command:elem} // Отправляем на вывод, новую строку. С ней может работать другой конвеер, который делает, что то другое
			}
		case <-ticker.C: // Попадаем сюда когда нет работы, канал пуст и тут можем узнать, может пора закругляться
			if p.stopPrepare.x { // Функции сверху обрабатывают два типа сигнала, это по прихода из канала или просто вызов Stop, и они передают сюда true, значит нам пора выключаться
				// Какой то интересный завершающий код
				fmt.Printf("Завершаю работу, я это миньен %d, имя: %s\n",gophere,p.boxData) //Печатаем ход работ. И в тексте добавляем полезную информацию, о количестве завершеных им операций и порядковый номер миньона
				p.stopX <- true // Посылаем сигнал, что миньон прибит
				return // Собственно ей конец
			}
		}
	}
}

